package tx

import (
	"context"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/GoGraph/db"
	"github.com/GoGraph/dbs"
	param "github.com/GoGraph/dygparam"
	slog "github.com/GoGraph/syslog"
	"github.com/GoGraph/tbl"
	"github.com/GoGraph/tx/mut"
	"github.com/GoGraph/tx/query"
	"github.com/GoGraph/uuid"
)

func syslog(s string) {
	slog.Log("Tx:", s)
}

// Handle represents a transaction composed of 1 to many mutations.
type Handle = TxHandle

type Label string

// API determines db API to use
// for Spaneers SQL db, there is no distinction between single (UpdateItem,putItem,DeleteItem), batch (put,delete ops) and transaction.
// for no-SQL there is a distinct API for each api type.

type TxRequest = TxHandle

//type TxTag Label

type TxHandle struct {
	Tag string
	api db.API
	ctx context.Context
	//
	dbHdl   db.Handle // database handle. mysql sql.DB, [default: either, spanner spanner.NewClient, dynamodb dynamodb.New]
	maxMuts int       // depending on database driver. -1 or param.MaxMutations
	options db.Options
	//
	prepare bool // reuest to prepare all mutations or not.
	//
	i        int // batch counter ???
	mergeMut bool
	am       *mut.Mutation  // active-mutation (i.e. current) generated by MergeMutation
	sm       *mut.Mutation  // source-mutation used during MergeMutation
	m        *mut.Mutations // ptr to array of mutations in active batch.
	b        int            //batch id
	//	l      sync.Mutex
	batch []*mut.Mutations // batch containing array of array of mutations. TODO: consider adding API to a batch, so one batch can use the transaction API, another a single API etc.
	// all executed under one txHandle rather than multiple. Advantages???
	done  bool // has been executed.
	admin bool // tx associated with some sort of administration operation - not to be monitored.
	// TODO: should we have a logger??
	TransactionStart time.Time
	TransactionEnd   time.Time
	//
	Err error
}

func (h *TxHandle) String() string {

	var (
		l int
		s strings.Builder
		m map[string]int
	)
	m = make(map[string]int)
	s.WriteString(fmt.Sprintf("\ntag: %s\n", h.Tag))
	s.WriteString(fmt.Sprintf("mutations in active batch: %d \n", len(*h.m)))
	s.WriteString(fmt.Sprintf("#non-active batches:  %d\n", len(h.batch)))

	for _, v := range h.batch {
		l += len(*v)
		for _, vv := range *v {
			m[vv.(*mut.Mutation).GetOpr().String()]++
		}
	}

	for _, v := range *h.m {
		m[v.(*mut.Mutation).GetOpr().String()]++
	}
	s.WriteString(fmt.Sprintf("Mutations in non-active batches: %d\n", l))
	s.WriteString(fmt.Sprintf("b:    %d\n", h.b))
	s.WriteString(fmt.Sprintf("Puts:    %d\n", m[mut.Insert.String()]))
	s.WriteString(fmt.Sprintf("Updates: %d\n", m[mut.Update.String()]))
	s.WriteString(fmt.Sprintf("Merge:   %d\n", m[mut.Merge.String()]))
	s.WriteString(fmt.Sprintf("Deletes: %d\n", m[mut.Delete.String()]))
	return s.String()

}

// NewTx - new transactionm, treat all associated mutations as part of a single transaction.
// Can be disabled by setting parameter: "transactions=disabled", which effectively halves the
// write capacity units compared to its transaction equivalent.
func NewTx(tag string, m ...*mut.Mutation) *TxHandle {

	tx := &TxHandle{Tag: tag, m: new(mut.Mutations), api: db.TransactionAPI, maxMuts: param.MaxMutations, dbHdl: db.GetDefaultDBHdl()}

	if tag == param.StatsSystemTag {
		tx.admin = true
	}
	if len(m) > 0 {
		for _, v := range m {
			tx.Add(v)
		}
	}

	return tx

}

//
// ****************************** Choose API ************************************
//
// NewCTx transacational API with context
func NewTxContext(ctx context.Context, tag string, m ...*mut.Mutation) *TxHandle {

	tx := &TxHandle{Tag: tag, ctx: ctx, m: new(mut.Mutations), api: db.TransactionAPI, maxMuts: param.MaxMutations, dbHdl: db.GetDefaultDBHdl()}

	if tag == param.StatsSystemTag {
		tx.admin = true
	}
	if len(m) > 0 {
		for _, v := range m {
			tx.Add(v)
		}
	}

	return tx

}

// NewSingle - single api not involved as a transaction. Allows puItem, deleteItem, updateItem operations without the overhead
// of being in a transaction. This essentially represents the behaviour of GoGraph prior to the inclusion of transactions.
func NewSingle(tag string) *TxHandle {

	return New(tag)

}

// New - default represents standard api
func New(tag string, m ...*mut.Mutation) *TxHandle {

	tx := &TxHandle{Tag: tag, api: db.StdAPI, m: new(mut.Mutations), maxMuts: param.MaxMutations, dbHdl: db.GetDefaultDBHdl()}

	if tag == param.StatsSystemTag {
		tx.admin = true
	}
	if len(m) > 0 {
		for _, v := range m {
			tx.Add(v)
		}
	}

	return tx

}

// NewC - default represents standard api with context
func NewContext(ctx context.Context, tag string, m ...*mut.Mutation) *TxHandle {

	tx := &TxHandle{Tag: tag, ctx: ctx, api: db.StdAPI, m: new(mut.Mutations), maxMuts: param.MaxMutations, dbHdl: db.GetDefaultDBHdl()}

	if tag == param.StatsSystemTag {
		tx.admin = true
	}
	if len(m) > 0 {
		for _, v := range m {
			tx.Add(v)
		}
	}

	return tx

}

// NewBatch -  bundle put/deletes as a batch. Provides no transaction consistency but is cheaper to run. No conditions allowed??
func NewBatch(tag string, m ...*mut.Mutation) *TxHandle {

	tx := &TxHandle{Tag: tag, api: db.BatchAPI, m: new(mut.Mutations), maxMuts: param.MaxMutations, dbHdl: db.GetDefaultDBHdl()}

	if tag == param.StatsSystemTag {
		tx.admin = true
	}
	if len(m) > 0 {
		for _, v := range m {
			tx.Add(v)
		}
	}

	return tx

}

// NewBatch -  bundle put/deletes as a batch. Provides no transaction consistency but is cheaper to run. No conditions allowed??
func NewBatchContext(ctx context.Context, tag string, m ...*mut.Mutation) *TxHandle {

	tx := &TxHandle{Tag: tag, ctx: ctx, api: db.BatchAPI, m: new(mut.Mutations), maxMuts: param.MaxMutations, dbHdl: db.GetDefaultDBHdl()}

	if tag == param.StatsSystemTag {
		tx.admin = true
	}
	if len(m) > 0 {
		for _, v := range m {
			tx.Add(v)
		}
	}

	return tx

}

// NewBatch -  bundle put/deletes as a batch. Provides no transaction consistency but is cheaper to run. No conditions allowed??
func NewOptim(tag string, m ...*mut.Mutation) *TxHandle {

	tx := &TxHandle{Tag: tag, api: db.OptimAPI, m: new(mut.Mutations), maxMuts: param.MaxMutations, dbHdl: db.GetDefaultDBHdl()}

	return tx.new(m...)
}

func (h *TxHandle) new(m ...*mut.Mutation) *TxHandle {

	if h.Tag == param.StatsSystemTag {
		h.admin = true
	}
	if len(m) > 0 {
		for _, v := range m {
			h.Add(v)
		}
	}

	return h
}

func (h *TxHandle) Prepare() *TxHandle {
	h.prepare = true
	return h
}

// Add exists to support legacy tx. It has been replaced by New* implemenations below
// which have built in add functionality. There will always be atleast one argument (mutation) supplied
func (h *TxHandle) Add(m ...dbs.Mutation) {

	for _, v := range m {
		h.add(v)
	}
}

// add a new mutation to active batch. Note the client will/can modify the mutation (i.e. AddMember) after it is added.
// if number of mutations in active batch exceeds permitted maximum it will be added it to batch-of-batches and
// a new active batch created
// TODO: investigate  Execute() as goroutine, maybe a nice extension.
func (h *TxHandle) add(m dbs.Mutation) {
	if m == nil {
		return
	}

	// check if m already added
	for _, v := range *h.m {
		if v == m {
			return
		}
	}

	// check if active batch contains more than permitted mutations
	if len(*h.m) == h.maxMuts {
		h.MakeBatch()
	}
	// add mutation to active batch
	*h.m = append(*h.m, m)
}

// add active batch to batch-of-batches and create new active batch.
func (h *TxHandle) MakeBatch() error {
	// serialise access to batch if Executes are run as goroutines.
	// h.l.Lock()
	// defer h.l.Unlock()
	if len(*h.m) == 0 {
		// no active mutations batch - ignore MakeBatch request
		return nil
	}
	h.b++
	// add active mutation batch to array of batches
	h.batch = append(h.batch, h.m)
	// create new active batch
	h.m = new(mut.Mutations)

	return nil
}

//
// ****************************** New Mutation ************************************
//
func (h *TxHandle) NewMutation(table tbl.Name, pk uuid.UID, sk string, opr mut.StdMut) *mut.Mutation {
	m := mut.NewMutation(table, pk, sk, opr)
	h.add(m)
	return m
}

func (h *TxHandle) NewInsert(table tbl.Name) *mut.Mutation {
	m := mut.NewInsert(table)
	h.add(m)
	return m
}

func (h *TxHandle) NewUpdate(table tbl.Name) *mut.Mutation {
	if h.api == db.BatchAPI {
		panic(fmt.Errorf("Cannot have an Update operation included in a batch"))
	}
	m := mut.NewUpdate(table)
	h.add(m)
	return m
}

func (h *TxHandle) NewMerge(table tbl.Name) *mut.Mutation {
	if h.api == db.BatchAPI {
		panic(fmt.Errorf("Cannot have a Merge operation included in a batch"))
	}
	m := mut.NewMerge(table)
	h.add(m)
	return m
}

// Truncate table
func (h *TxHandle) NewTruncate(tbs []tbl.Name) {

	for _, table := range tbs {
		m := mut.Truncate(table)
		h.add(m)
	}

}

// func (h *TxHandle) NewBulkInsert(table tbl.Name) *mut.Mutation {
// 	if tx.api != batch {

// 	}
// 	m := mut.NewInsert(table)
// 	h.add(m)
// 	return m
// }

// func (h *TxHandle) NewBulkDelete(table tbl.Name) *mut.Mutation {
// 	m := mut.NewDelete(table)
// 	h.add(m)
// 	return m
// }

// func (h *TxHandle) NewBulkMerge(table tbl.Name) *mut.Mutation {
// 	m := mut.NewBulkMerge(table)
// 	h.add(m)
// 	return m
// }

func (h *TxHandle) MaxMutations() bool {
	return h.m.NumMutations()+1 == param.MaxMutations
}

// GetMutation retrieves the i'th mutation. Given mutations are batched into 25 mutations slices need to determine what slice and then index into it.
func (h *TxHandle) GetMutation(i int) (*mut.Mutation, error) {

	var r, b int

	if len(h.batch) == 0 {
		if i < len(*h.m) {
			return (*h.m)[i].(*mut.Mutation), nil
		}
		return nil, fmt.Errorf("GetMutation error. Requested mutation index %d is greater than number of mutations", i)
	}
	if i != 0 {
		b = int(i/param.MaxMutations) - 1
		r = i - b*param.MaxMutations
	}

	if b < len(h.batch) {
		if r < len(*h.m) {
			return (*h.batch[b])[r].(*mut.Mutation), nil
		}
	}
	return nil, fmt.Errorf("GetMutation error. Requested mutation index %d is greater than number of mutations", i)

}

func (h *TxHandle) HasMutations() bool {

	if h.b > 0 || len(*h.m) > 0 {
		return true
	}
	return false
}

func (h *TxHandle) DB(s string, opt ...db.Option) *TxHandle {
	var err error
	h.dbHdl, err = db.GetDBHdl(s)
	if err != nil {
		panic(err)
	}
	h.options = opt
	return h
}

func (h *TxHandle) Close() {

	if h.prepare {
		h.dbHdl.CloseTx(h.batch)
	}

}

func (h *TxHandle) Persist() error {
	return h.Execute()
}

func (h *TxHandle) Commit() error {
	return h.Execute()
}

func (h *TxHandle) Execute(m ...*mut.Mutation) error {

	var err error

	if h.done {
		syslog(fmt.Sprintf("Error: transaction %q has already been executed", h.Tag))
		return fmt.Errorf("Transaction has already been executed.")
	}
	// append passed in mutation(s) to transaction
	if len(m) > 0 {
		for _, v := range m {
			h.Add(v)
		}
	}
	// are there active mutations?
	if h.b == 0 && len(*h.m) == 0 {
		syslog(fmt.Sprintf("No mutations in transaction %q to execute", h.Tag))
		return nil
	}

	// add current active batch  to array-of-batches
	if len(*h.m) != 0 {
		// assign to a batch under either of the following conditions
		if h.b == 0 || h.batch[len(h.batch)-1] != h.m {
			if err := h.MakeBatch(); err != nil {
				return err
			}
		}
	}

	h.TransactionStart = time.Now()

	err = h.dbHdl.Execute(h.ctx, h.batch, h.Tag, h.api, h.prepare, h.options...)

	h.TransactionEnd = time.Now()

	if err != nil {
		return err
	}
	// nullify pointers so transaction cannot be repeated.
	h.m = nil
	h.batch = nil
	h.done = true

	return nil

}

// ****************************** New Query API ************************************

type QHandle struct {
	dbHdl              db.Handle            // mysql handle, [default: either, spanner spanner.NewClient, dynamodb dynamodb.New]
	options            db.Options           // []db.Option
	*query.QueryHandle                      // GoGraph query handle - single thread
	workers            []*query.QueryHandle // GoGraph query handle's for parallel scans - one per parallel thread
}

func NewQuery(tbln tbl.Name, label string, idx ...tbl.Name) *QHandle {
	if err := tbl.IsRegistered(tbln); err != nil {
		panic(err)
	}

	if len(idx) > 0 {
		if err := tbl.IsRegistered(idx[0]); err != nil {
			return nil
		}
		return &QHandle{QueryHandle: query.New(tbln, label, idx[0]), dbHdl: db.GetDefaultDBHdl()}
	}
	return &QHandle{QueryHandle: query.New(tbln, label), dbHdl: db.GetDefaultDBHdl()}
}

func NewQuery2(ctx context.Context, label string, tbln tbl.Name, idx ...tbl.Name) *QHandle {
	if err := tbl.IsRegistered(tbln); err != nil {
		panic(err)
	}

	if len(idx) > 0 {
		if err := tbl.IsRegistered(idx[0]); err != nil {
			panic(err)
		}
		return &QHandle{QueryHandle: query.NewCtx(ctx, tbln, label, idx[0]), dbHdl: db.GetDefaultDBHdl()}
	}
	return &QHandle{QueryHandle: query.NewCtx(ctx, tbln, label), dbHdl: db.GetDefaultDBHdl()}
}

func (h *QHandle) DB(s string, opt ...db.Option) *QHandle {
	var err error
	h.dbHdl, err = db.GetDBHdl(s)
	if err != nil {
		panic(err)
	}
	h.options = opt
	return h
}

func (h *QHandle) Prepare() *QHandle {

	h.SetPrepare()
	return h
}

func (h *QHandle) Close() error {

	return h.dbHdl.Close(h.QueryHandle)
}

//func (h *QHandle) ChanOutput(s interface{}) *QHandle {} // s is a chan ?. Can ChanOutput direct data onto s?

func (h *QHandle) Workers() []*query.QueryHandle {

	// create n workers requires n QueryHandle's

	h.workers = make([]*query.QueryHandle, h.GetParallel())

	r := reflect.ValueOf(h.Fetch()).Elem() // TODO: consider making slice parallel in size when client does

	for i := 0; i < h.GetParallel(); i++ {

		d := h.QueryHandle.Duplicate()
		d.SetWorderId(i)

		// ptx [][]rec
		// operation we want to emulate in reflect is select(&[]rec) which will be assigned to q.fetch inteface{}
		d.SetFetch(r.Index(i).Addr().Interface())

		h.workers[i] = d

	}

	return h.workers

}

func (h *QHandle) Execute(w ...int) error {

	switch len(w) {
	case 0:
		return h.dbHdl.ExecuteQuery(h.QueryHandle, h.options...)
	default:
		return h.dbHdl.ExecuteQuery(h.workers[w[0]], h.options...)
	}

}

////////////////////////////////////////////////// DML: MergeMutation ////////////

func (h *TxHandle) MergeMutation(table tbl.Name, pk uuid.UID, sk string, opr mut.StdMut) *TxHandle {

	h.mergeMut = true
	// null source mutation from previous MergeMutation
	h.sm = nil
	h.am = nil
	// assign active mutation with new mutation and add to active batch
	if opr == mut.Merge {
		panic(fmt.Errorf("Merge not supported in a MergeMutation operation. Use Insert, Update or Delete"))
	}
	h.am = mut.NewMutation(table, pk, sk, opr)

	h.sm = h.FindSourceMutation(table, pk, sk)
	if h.sm == nil {
		h.add(h.am)
	}

	return h
}

func (h *TxHandle) FindSourceMutation(table tbl.Name, pk uuid.UID, sk string) *mut.Mutation {

	// cycle through batch of mutation batches .
	for _, bm := range h.batch {

		sm := bm.FindMutation(table, pk, sk)
		if sm != nil {
			return sm
		}
	}
	// search active batch if source mutation not found.
	return h.m.FindMutation(table, pk, sk)
}

func (h *TxHandle) AddCondition(cond mut.Cond, attr string, value ...interface{}) *TxHandle {
	if h.sm == nil {
		h.am.AddCondition(cond, attr, value)
	} else {
		h.sm.AddCondition(cond, attr, value)
	}
	return h
}

func (h *TxHandle) AddMember(attr string, value interface{}, opr_ ...mut.MutOpr) *TxHandle {

	var opr mut.MutOpr
	// am - active mutation
	// bm - batch of batch mutations
	// sm - source mutation
	if !h.mergeMut {
		panic(fmt.Errorf("tx.AddMember method can only be part of a MergeMutation operation. "))
	}
	// no source mutation exists - meaning no mergeMutation requirement
	if h.sm == nil {

		h.am.AddMember(attr, value, opr_...)

	} else {

		// *** merge current mutation with source mutation ***

		//h.am.GetOpr() == mut.Update { // && mut.IsArray(value) { // MergeMutation built for DP and DP always uses arrays.

		//fmt.Println("AddMember - update h.sm = ", h.sm)

		// fmt.Printf("Found source mutation %#v\n", *h.sm)
		// fmt.Printf(" now add mutation data  %#v\n", value)
		// remove newly created mutation and merge its data with source mutation
		// precedence dot notation, slice operator, pointer deref
		//*h.m = (*h.m)[:len(*h.m)-1]
		// if len(*h.m) == 0 {
		// 	fmt.Println("Batch size = ", len(h.batch))
		// 	if len(h.batch) > 0 {
		// 		l := len(*h.batch[len(h.batch)-1])
		// 		*h.batch[len(h.batch)-1] = (*h.batch[len(h.batch)-1])[:l-1]
		// 	}
		// } else {
		// 	*h.m = (*h.m)[:len(*h.m)-1]
		// }
		var found bool
		sa := h.sm.GetMembers()
		for i, v := range sa {
			// all members of active mutation match previous mutation - found source/original mutation
			if v.Name != attr {
				continue
			}
			opr = v.Opr
			found = true
			if opr == mut.Remove {
				// set member operator to remove
				v.Opr = mut.Remove
				return h
			}

			switch x := v.Value.(type) {

			case int64:

				if n, ok := value.(int64); !ok {
					panic(fmt.Errorf("AddMember2: Expected int64 got passed in value of %T", value))
				} else {
					switch opr {
					case mut.Inc:
						x += n
						sa[i].Value = x
					case mut.Subtract:
						x -= n
						sa[i].Value = x
					case mut.Set:
						sa[i].Value = x
					default:
						panic(fmt.Errorf("Expected member operator of Inc, Set, Add, Subtract got %q", opr))
					}
				}

			case int:

				if n, ok := value.(int); !ok {
					panic(fmt.Errorf("AddMember2: Expected int got passed in value of %T", value))
				} else {
					switch opr {
					case mut.Inc:
						x += n
						sa[i].Value = x
					case mut.Subtract:
						x -= n
						sa[i].Value = x
					case mut.Set:
						sa[i].Value = x
					default:
						panic(fmt.Errorf("Expected member operator of Inc, Set, Add, Subtract got %q", opr))
					}
				}

			case float64:

				if n, ok := value.(float64); !ok {
					panic(fmt.Errorf("AddMember2: Expected float64 got passed in value of %T", value))
				} else {
					switch opr {
					case mut.Inc:
						x += n
						sa[i].Value = x
					case mut.Subtract:
						x -= n
						sa[i].Value = x
					case mut.Set:
						sa[i].Value = x
					default:
						panic(fmt.Errorf("Expected member operator of Inc, Set, Add, Subtract got %q", opr))
					}
				}

			case bool:

				if _, ok := value.(bool); !ok {
					panic(fmt.Errorf("AddMember2: Expected bool got passed in value of %T", value))
				}
				sa[i].Value = value

			case [][]byte:

				if _, ok := value.([][]byte); !ok {
					panic(fmt.Errorf("Expected member type [][]byte, passed in value of type %T for attribute %s ", value, v.Name))
				}
				switch opr {
				case mut.Set:
					sa[i].Value = x
					panic("[][]byte set not append in tx.AddMember")
				default: // Append
					if s, ok := value.([][]byte); !ok {
						panic(fmt.Errorf("AddMember2: Expected []int64 got %T", x))
					} else {
						x = append(x, s...)
						sa[i].Value = x
						//	fmt.Printf("====. merged [][]byte  %s %d\n", sa[i].Name, len(sa[i].Value.([][]byte)))
					}
				}

			case []uuid.UID:

				if _, ok := value.([]uuid.UID); !ok {
					if _, ok := value.([][]byte); !ok {
						panic(fmt.Errorf("Expected member type []uuid.UID, passed in value of type %T for attribute %s ", value, v.Name))
					}
				}
				switch opr {
				case mut.Set:
					sa[i].Value = x
					panic("[]uuid.UID set not append in tx.AddMember")
				default: // Append
					if s, ok := value.([]uuid.UID); !ok {
						panic(fmt.Errorf("AddMember2: Expected []int64 got %T", x))
					} else {
						x = append(x, s...)
						sa[i].Value = x
						//	fmt.Printf("====. merged []uuid.UID %s %d\n", sa[i].Name, len(sa[i].Value.([][]uuid.UID)))
					}
				}

			case []string:
				if _, ok := value.([]string); !ok {
					panic(fmt.Errorf("Expected member type []string, passed in value of type %T for attribute %s ", value, v.Name))
				}
				switch opr {
				case mut.Set:
					sa[i].Value = x
				default: // Append
					if s, ok := value.([]string); !ok {
						panic(fmt.Errorf("AddMember2: Expected []string got %T", x))
					} else {
						x = append(x, s...)
						sa[i].Value = x
						//	fmt.Printf("====. merged %s %d\n", sa[i].Name, len(sa[i].Value.([]int)))
					}
				}

			case []int64:
				if _, ok := value.([]int64); !ok {
					panic(fmt.Errorf("Expected member type []int64, passed in value of type %T for attribute %s ", value, v.Name))
				}
				switch opr {
				case mut.Set:
					sa[i].Value = x
				default: // Append
					if s, ok := value.([]int64); !ok {
						panic(fmt.Errorf("AddMember2: Expected []int64 got %T", x))
					} else {
						x = append(x, s...)
						sa[i].Value = x
						//	fmt.Printf("====. merged %s %d\n", sa[i].Name, len(sa[i].Value.([]int)))
					}
				}

			case []int:
				if _, ok := value.([]int); !ok {
					panic(fmt.Errorf("Expected member type []int, passed in value of type %T for attribute %s ", value, v.Name))
				}
				switch opr {
				case mut.Set:
					sa[i].Value = x
				default: // Append
					if s, ok := value.([]int); !ok {
						panic(fmt.Errorf("AddMember2: Expected []int64 got %T", x))
					} else {
						x = append(x, s...)
						sa[i].Value = x
						//	fmt.Printf(" =. merged %s %d\n", sa[i].Name, len(sa[i].Value.([]int)))
					}
				}

			case []float64:
				if _, ok := value.([]float64); !ok {
					panic(fmt.Errorf("Expected member type []float64, passed in value of type %T for attribute %s ", value, v.Name))
				}
				switch opr {
				case mut.Set:
					sa[i].Value = x
				default: // Append
					if s, ok := value.([]float64); !ok {
						panic(fmt.Errorf("AddMember2: Expected []float64 got %T", x))
					} else {
						x = append(x, s...)
						sa[i].Value = x
						//	fmt.Printf("====. merged %s %d\n", sa[i].Name, len(sa[i].Value.([]int)))
					}
				}

			case []bool:
				if _, ok := value.([]bool); !ok {
					panic(fmt.Errorf("Expected member type []bool, passed in value of type %T for attribute %s ", value, v.Name))
				}
				switch opr {
				case mut.Set:
					sa[i].Value = x
				default: // Append
					if s, ok := value.([]bool); !ok {
						panic(fmt.Errorf("AddMember2: Expected []int64 got %T", x))
					} else {
						x = append(x, s...)
						sa[i].Value = x
						//	fmt.Printf("====. merged %s %d\n", sa[i].Name, len(sa[i].Value.([]int)))
					}
				}
			}
		}

		if !found {
			// no attr exists in the source mutation - lets create one
			syslog(fmt.Sprintf("create member %s as it does not exist in source mutation.", attr))
			h.sm.AddMember(attr, value)
		}
	}
	return h
}
